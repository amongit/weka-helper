http://zdnet.com.feedsportal.com/c/35462/f/675642/s/442ff310/sc/4/l/0L0Szdnet0N0Carticle0Cdesigning0Etomorrows0Eapplications0Etoday0C0Tftag0FRSSbaffb68/story01.htm
Designing Tomorrow’s Applications Today
Is there really any point in developing your own applications anymore? The growth in vertical solutions is phenomenal. For example, BCC Research is predicting that health care technology will more than double from about $11.2 billion in 2012 to $26.1 billion in 2017. The same trends are noticeable in other industries too.
Whether your business operates in energy, telecommunications, or the financial sector, there is a lot of good off-the-shelf software on the market, and software-as-a-service is booming. Furthermore, good engineers are not cheap, and lifecycle management takes a lot of time and effort. The truth is that many companies probably don’t need to develop and maintain their own code.
At the same time, as we saw in the previous post, In Search of Innovation , a key to innovation is responsiveness to business demands. And it is hard to match the power and flexibility of controlling your own applications and tuning them to the specific requirements of your customers, suppliers, and employees.
The critical question to ponder is how to build new business applications so that they will be successful as the datacenter evolves. There are a number of considerations, mainly revolving around speed and flexibility.
Rapid deployment is a must. When a business needs an application, it usually wants it as soon as possible. The longer it takes to roll out, the less total value it can deliver. One way to reduce production time is to make sure the infrastructure is ready (for example: by creating resource pools that only require the touch of a button for allocation when the application goes live).
Automation is another enabler. An orchestration engine can accelerate deployment, while at the same time reducing the operational effort and likelihood of human error. Automation is also critical for applications that need to scale on demand. It is often difficult to project the volume of usage before an application goes live. Sometimes there are pleasant surprises, and adoption is much higher than anticipated. But this is only helpful if the application is able to recognize the increased demand and scale accordingly by internally allocating more resources as they are needed.
Above all, remember that the development environment needs to be flexible. Some engineers may have a history of using Visual Studio while others have more experience with Eclipse. Cloud services, such as Windows Azure — which support plugins to multiple environments — give you the latitude to accommodate distinct groups of developers.
You also never know what languages tomorrow’s programmers will prefer. Even today’s landscape is fragmented with enthusiasts specializing in C++, C#, Java, Ruby, Python, and many others. You might want to acquire code in any one of these or find that budding engineers have chosen yet another language as their own.
Flexibility also means that client applications should work reliably on multiple devices. The development environment must accommodate smartphones, tablets, laptops, and desktops with various form factors and hardware configurations. Ideally, it will also allow you to maximize the code re-use between these target platforms.
On the server side, the applications should be deployable within an on-premises environment, such as Windows Server 2012, or in the cloud, for example on Windows Azure. In fact, the applications could even run in a unified operating and management environment — such as System Center 2012 — that spans your datacenter and the cloud. This means finding a platform that is available in each of the scenarios but also involves writing code that is able to cater to a distributed environment with a high level of parallelization and immunity to high latency.
Perhaps the most exciting prospect of applications developed within this new paradigm is that they open up new opportunities for application lifecycle management. Rapid deployment and resource relinquishing makes it easier to test and stage services. By leveraging rapid prototyping, continuous integration, and continuous deployment, the IT department can increase developer productivity, ensure even faster availability for the applications, and incorporate business feedback almost instantaneously.
